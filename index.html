<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HackTown 2025 Schedule Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: system-ui, sans-serif; margin: 2em; background: #f8f8fb; color: #222; }
    h1 { font-size: 2em; }
    .controls { margin-bottom: 2em; }
    label { margin-right: 1em; }
    .day { margin-top: 2em; }
    .event { margin-left: 1em; margin-bottom: .8em; padding: .7em 1em; background: #fff; border-radius: 7px; box-shadow: 0 2px 8px #0001; }
    .event-title { font-weight: bold; }
    .event-place { color: #006; font-size: .95em; }
    #loading { color: #444; font-style: italic; }
    @media (max-width: 600px) {
      body { margin: .7em; }
      .event { padding: .6em; }
    }
  </style>
</head>
<body>
  <h1>HackTown 2025 Schedule Viewer</h1>
  <div class="controls">
    <span id="serverStatus"></span>
    <label>
      Date:
      <select id="dateFilter"><option value="">All Dates</option></select>
    </label>
    <label>
      Time filter:
      <input type="text" placeholder="e.g. 09:00 or 10:00-12:00" id="timeFilter" size="13">
    </label>
    <button id="filterBtn">Filter</button>
  </div>
  <div id="loading">Loading schedule from server...</div>
  <div id="schedule"></div>
  <script>
    // Use only America/Sao_Paulo timezone everywhere
    const FIXED_TIMEZONE = "America/Sao_Paulo";

    // ---- Time filter parsing ----
    function parseTimeRange(str) {
      let s = str.trim();
      if (!s) return null;
      if (s.includes('-')) {
        let [start, end] = s.split('-').map(x => x.trim());
        return [start, end];
      } else {
        return [s, s];
      }
    }
    function parseHHMM(s) {
      let [h, m] = s.split(':').map(Number);
      return { h, m };
    }
    function timeObjToMinutes(timeObj) {
      return timeObj.h * 60 + timeObj.m;
    }
    function localTimeToMinutes(d) {
      return d.getHours()*60 + d.getMinutes();
    }
    // ---- Main rendering ----
    let allEvents = [];
    let uniqueDays = [];
    function render(events, filterTimeRange, filterDayKey) {
      const scheduleDiv = document.getElementById("schedule");
      document.getElementById("loading").style.display = "none";
      if (!events.length) {
        scheduleDiv.innerHTML = "<p>No data loaded.</p>";
        return;
      }

      // Sort by start_time
      events = events.slice().sort((a, b) => a.start_time.localeCompare(b.start_time));
      // Group by day
      let days = {};
      events.forEach(ev => {
        let localStart = toLocal(ev.start_time, FIXED_TIMEZONE);
        let dayKey = localStart.toLocaleDateString(undefined, { weekday: "long", year: "numeric", month: "long", day: "numeric" });
        if (!days[dayKey]) days[dayKey] = [];
        days[dayKey].push(ev);
      });

      // Filtering by date
      if (filterDayKey) {
        for (let day in days) {
          if (day !== filterDayKey) {
            delete days[day];
          }
        }
      }

      // Filtering by time
      if (filterTimeRange) {
        const [startStr, endStr] = filterTimeRange;
        const startObj = parseHHMM(startStr);
        const endObj = parseHHMM(endStr);
        const startMin = timeObjToMinutes(startObj);
        const endMin = timeObjToMinutes(endObj);

        for (let day in days) {
          days[day] = days[day].filter(ev => {
            const startLocal = toLocal(ev.start_time, FIXED_TIMEZONE);
            const endLocal = toLocal(ev.end_time, FIXED_TIMEZONE);
            const evStartMin = localTimeToMinutes(startLocal);
            const evEndMin = localTimeToMinutes(endLocal);

            if (startMin === endMin) {
              return evStartMin <= startMin && startMin < evEndMin;
            } else {
              return !(evEndMin <= startMin || evStartMin >= endMin);
            }
          });
        }
      }

      // Render HTML
      let html = "";
      for (let day of Object.keys(days).sort((a, b) => {
        let getDate = txt => new Date(days[txt][0] ? toLocal(days[txt][0].start_time, FIXED_TIMEZONE).toDateString() : txt);
        return getDate(a) - getDate(b);
      })) {
        if (!days[day].length) continue;
        html += `<div class="day"><h2>${day}</h2>`;
        for (let ev of days[day]) {
          let localStart = toLocal(ev.start_time, FIXED_TIMEZONE);
          let localEnd = toLocal(ev.end_time, FIXED_TIMEZONE);
          let startStr = localStart.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
          let endStr = localEnd.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
          let place = ev.place || "<em>no place</em>";
          html += `<div class="event">
            <span class="event-title">${startStr} - ${endStr} | ${ev.title}</span>
            <div class="event-place">@ ${place}</div>
          </div>`;
        }
        html += "</div>";
      }
      scheduleDiv.innerHTML = html || "<p>No events match the filter.</p>";
    }

    function toLocal(isoString, timezone) {
      if (window.luxon) {
        return window.luxon.DateTime.fromISO(isoString, { zone: 'utc' }).setZone(timezone).toJSDate();
      } else {
        return new Date(isoString);
      }
    }

    // ---- UI handlers ----
    document.getElementById("filterBtn").onclick = function() {
      render(
        allEvents,
        parseTimeRange(document.getElementById("timeFilter").value),
        document.getElementById("dateFilter").value
      );
    };
    document.getElementById("timeFilter").onkeydown = function(e) {
      if (e.key === "Enter") document.getElementById("filterBtn").click();
    };
    document.getElementById("dateFilter").onchange = function() {
      render(
        allEvents,
        parseTimeRange(document.getElementById("timeFilter").value),
        document.getElementById("dateFilter").value
      );
    };

    // ---- Luxon fallback warning ----
    (function addLuxonScript() {
      if (window.luxon) return;
      let s = document.createElement("script");
      s.src = "https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js";
      s.onload = () => {
        updateDateDropdown(allEvents, FIXED_TIMEZONE);
        render(
          allEvents,
          parseTimeRange(document.getElementById("timeFilter").value),
          document.getElementById("dateFilter").value
        );
      };
      document.head.appendChild(s);
    })();

    // ---- Load all_schedules.json from server ----
    function loadScheduleFromServer() {
      const status = document.getElementById('serverStatus');
      fetch('all_schedules.json')
        .then(resp => {
          if (!resp.ok) throw new Error("HTTP " + resp.status);
          status.textContent = "Schedule loaded from server.";
          return resp.json();
        })
        .then(data => {
          allEvents = data;
          updateDateDropdown(allEvents, FIXED_TIMEZONE);
          render(
            allEvents,
            parseTimeRange(document.getElementById("timeFilter").value),
            document.getElementById("dateFilter").value
          );
        })
        .catch(err => {
          status.textContent = "Failed to load all_schedules.json from server: " + err;
          document.getElementById("loading").style.display = "none";
        });
    }

    // ---- Populate date dropdown ----
    function updateDateDropdown(events, timezone) {
      let dateSel = document.getElementById("dateFilter");
      let daysSet = new Set();
      events.forEach(ev => {
        let localStart = toLocal(ev.start_time, timezone);
        let dayKey = localStart.toLocaleDateString(undefined, { weekday: "long", year: "numeric", month: "long", day: "numeric" });
        daysSet.add(dayKey);
      });
      let daysArr = Array.from(daysSet).sort((a, b) => {
        let getDate = txt => {
          let d = new Date(txt.replace(/^(\w+), /, ""));
          return d;
        };
        return getDate(a) - getDate(b);
      });

      // Save the currently selected value if possible
      let prev = dateSel.value;
      dateSel.innerHTML = `<option value="">All Dates</option>`;
      daysArr.forEach(day => {
        let opt = document.createElement("option");
        opt.value = day;
        opt.textContent = day;
        dateSel.appendChild(opt);
      });
      if (prev && daysArr.includes(prev)) dateSel.value = prev;
    }

    loadScheduleFromServer();
  </script>
</body>
</html>
